var util = require('util');
var crypto = require('crypto');
var events = require('events');
var querystring = require('querystring');
var WebSocket = require('websocket-client').WebSocket;
var UUID = require('node-uuid');

var JSON_RPC = require('./json-rpc');
var extend = require('./utils').extend;

function has(obj, key) {
  return Object.hasOwnProperty.call(obj, key);
}

var debug = function debug() {};

function Client(config) {
  if (!(this instanceof Client)) return new Client(config);

  this.secure = false;
  this.host = 'wsapi.darling.pusher.com';
  this.port = 8080;

  extend(this, config);

  // The connection associated with the client:
  // (only created on client.connect())
  this.connection = undefined;
  this.connection_id = undefined;

  // Used for client related events, eg, connection state changes.
  events.EventEmitter.call(this);

  // Callback storage for RPC requests:
  this._callbacks = {};

  // Storage of instances:
  this._channels = {};
  this._sockets = {};

  // used for the firehose of events relating to all
  // channels (and excluding events that happen on sockets).
  this.channels = new events.EventEmitter();

  // used for the firehose of events relating to all
  // sockets (and excluding events that happen on channels).
  this.sockets = new events.EventEmitter();

  // validation of configuration:
  if (!this.key) {
    throw new Error('Missing "key" configuration variable.');
  }

  if (!this.secret) {
    throw new Error('Missing "secret" configuration variable.');
  }

  if (!this.app_id) {
    throw new Error('Missing "app_id" configuration variable.');
  }
}

Client.Transport = WebSocket;
util.inherits(Client, events.EventEmitter);

exports.Client = Client;
exports.createClient = function(config) {
  return new Client(config);
};

/*-----------------------------------------------
  Hackery to enable dynamic debugging.
-----------------------------------------------*/
Client.prototype._debug = false;

// Special properties are kinda awesome.
Object.defineProperty(Client.prototype, 'debug', {
  enumerable: true,
  set: function(newValue) {
    this._debug = !!newValue;

    if (this._debug) {
      debug = function(data) {
        console.error('WSAPI: DEBUG:', data);
      };
    } else {
      debug = function(data) {};
    }
  },
  get: function() {
    return this._debug;
  }
});

Client.prototype.connect = function() {
  var client = this;
  var url = generateURL(this);

  debug('connecting to: ' + url);

  this.connection = new Client.Transport(url);

  this.connection.on('open', function() {
    debug('connection opened to WSAPI.');
  });

  this.connection.on('close', function() {
    client.emit('disconnected');
  });

  this.connection.on('wserror', function(err) {
    client.emit('error', err);
  });

  this.connection.on('message', function(message) {
    onIncomingMessage(client, message);
  });
};

Client.prototype.disconnect = function() {
  this.connection.close();
};


/*-----------------------------------------------
  Channel / Socket Stores:
-----------------------------------------------*/
Client.prototype.channel = function(name) {
  if (!has(this._channels, name)) {
    // TODO: swap args on Channel()
    this._channels[name] = new Channel(this, name);
  }

  return this._channels[name];
};

Client.prototype.hasChannel = function(name) {
  return has(this._channels, name);
};

Client.prototype.socket = function(id) {
  if (!has(this._sockets, id)) {
    this._sockets[id] = new Socket(this, id);
  }

  return this._sockets[id];
};

Client.prototype.hasSocket = function(id) {
  return has(this._sockets, id);
};

/*-----------------------------------------------
  A socket object allows for a nice interface
  for working with Socket's on the pusher
  network.
-----------------------------------------------*/

// TODO: swap args on Socket()
function Socket(client, id) {
  events.EventEmitter.call(this);

  this.id = id;
  this.client = client;
}

util.inherits(Socket, events.EventEmitter);

Socket.prototype.trigger = function(event, data, callback) {
  sendRequest(this.client, 'send_to_socket', {
    socket_id: this.id,
    event: event,
    data: data
  }, callback);
};


/*-----------------------------------------------
  A channel object allows a nice interface for
  interacting with channels.
-----------------------------------------------*/

// TODO: swap args on Channel()
function Channel(client, name) {
  events.EventEmitter.call(this);

  this.name = name;
  this.client = client;
}

util.inherits(Channel, events.EventEmitter);

Channel.prototype.trigger = function(event, data, socket_id, callback) {
  if (typeof socket_id === 'function') {
    callback = socket_id;
    socket_id = null;
  }

  sendRequest(this.client, 'send_to_channel', {
    channel: this.name,
    event: event,
    data: data,
    socket_id: socket_id
  }, callback);
};



/*-----------------------------------------------
  Private methods
-----------------------------------------------*/
function generateURL(client) {
  var port = client.port;
  var protocol = client.secure ? 'wss://' : 'ws://';
  var path = '/app/' + client.app_id;
  var params = querystring.stringify({
    auth_key: client.key,
    auth_timestamp: Math.floor(Date.now() / 1000),
    auth_version: '1.0'
  });

  var signature = crypto.createHmac('SHA256', client.secret)
    .update('WEBSOCKET\n' + path + '\n' + params)
    .digest('hex');

  return (
    protocol +
    client.host + ':' + client.port +
    path + '?' +
    params + '&auth_signature=' + signature
  );
}



function onIncomingMessage(client, message) {
  JSON_RPC.response.parse(message, function(err, parsed) {
    if (err !== null) {
    //  client.emit('error', err);
    } else {
      debug(parsed);
      if (parsed.id !== null) {
        // Replies to JSON-RPC calls MUST have an associated request ID.
        handleReply(client, parsed.id, parsed);
      } else {
        handleNotification(client, parsed);
      }
    }
  });
}

function handleReply(client, request_id, reply) {
  if (has(client._callbacks, request_id)) {
    var callback = client._callbacks[request_id];

    callback(reply.error, reply.result);

    delete client._callbacks[request_id];
  } else if (reply.error !== null) {
    client.emit('error', reply.error);
  }
}

function handleNotification(client, notification) {
  if (notification.error === null) {
    // switch for notification types
    var type = notification.result.event;
    var payload = notification.result.data;

    if (type === 'connection_established') {
      client.connection_id = payload.socket_id;
      client.emit('connected');
    } else if (type === 'socket_opened') {
      var socket_id = payload.socket_id;
      client.sockets.emit('open', socket_id);
    } else if (type === 'socket_closed') {
      var socket_id = payload.socket_id;
      client.sockets.emit('close', socket_id);

      // clean up:
      if (has(client._sockets, socket_id)) {
        // emit close on the socket instance:
        client.socket(socket_id).emit('close');

        // remove the socket from memory space:
        delete client._sockets[socket_id];
      }
    } else if (type === 'socket_message') {
      var socket_id = payload.socket_id;
      var data = payload.data;
      var event = payload.event;

      // If the event has a channel, this means that it originated
      // on a channel object, so it's an event on a channel.
      if (has(payload, 'channel')) {
        var channel_name = payload.channel;
        // Send to the firehose of channel events:
        client.channels.emit('event', event, channel_name, socket_id, data);
        client.channels.emit('event:' + event, channel_name, socket_id, data);

        if (has(client._channels, channel_name)) {
          var channel = client.channel(channel_name);

          channel.emit('event', event, socket_id, data);
          channel.emit('event:' + event, socket_id, data);
        }
      } else {
        // Send to the firehose of all socket events:
        client.sockets.emit('event', event, socket_id, data);
        client.sockets.emit('event:' + event, socket_id, data);

        if (has(client._sockets, socket_id)) {
          var socket = client.socket(socket_id);

          socket.emit('event', event, data);
          socket.emit('event:' + event, data);
        }
      }
    } else {
      debug('Unknown notification type: ' + type);
      debug('data: ' + JSON.stringify(notification));
    }
  } else {
    // Create an error object with the specified code, so you can
    // do things like:
    //
    //      client.on('error', function(e) {
    //        if (e.errno === 4210) {
    //          console.log('Woah, bad event name: ', e.message);
    //        }
    //      });
    //
    var error = new Error(notification.error.message);

    // set the errno on the object for easier error
    // identification.
    error.errno = notification.error.code;

    // If the user is not listening for client.on('error'), then
    // this will actually terminate the node.js process (fail-fast).
    client.emit('error', error);
  }
}

function sendRequest(client, method, params, callback) {
  if (client.connection && client.connection.readyState === client.connection.OPEN) {
    var id = UUID();
    var request = JSON_RPC.request.format(id, method, params);

    if (typeof callback === 'function') {
      client._callbacks[id] = callback;
    }

    client.connection.send(request);
  } else {
    if (typeof callback === 'function') {
      callback(new Error('Connection not opened'));
    } else {
      client.emit('error', new Error('Connection not opened'))
    }
  }
}
